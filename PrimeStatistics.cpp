#include <bits/stdc++.h>
using namespace std;

class PrimeStatistics
{
public:
	int mostCommonRemainder(int lowerBound, int upperBound, int modulo);
};

int PrimeStatistics::mostCommonRemainder (int lowerBound, int upperBound, int modulo) 
{
  vector <bool> isPrime(upperBound+1, true);
  isPrime[0] = isPrime[1] = false;
  for(int i = 0; i < (int)upperBound+1; ++i) if(isPrime[i]) {
    for(int j = i+i; j<= upperBound; j+=i)
      isPrime[j] = false;
  }

  vector <int> cnt(modulo, 0);
  for(int i = (int)lowerBound; i <= (int)upperBound; ++i) {
    if(isPrime[i] )
      cnt[i%modulo]++;
  }

  int id = 0;
  for(int i = 0; i < (int)modulo; ++i) {
    if(cnt[i] > cnt[id])
      id = i;
  }
  return id;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2;
	cout << "]" << endl;
	PrimeStatistics *obj;
	int answer;
	obj = new PrimeStatistics();
	clock_t startTime = clock();
	answer = obj->mostCommonRemainder(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	int p0;
	int p1;
	int p2;
	int p3;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 3;
	p1 = 14;
	p2 = 5;
	p3 = 3;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 3;
	p1 = 33;
	p2 = 1000;
	p3 = 3;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 25;
	p1 = 27;
	p2 = 17;
	p3 = 0;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 1;
	p1 = 200000;
	p2 = 2;
	p3 = 1;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = 1;
	p1 = 1000;
	p2 = 6;
	p3 = 5;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// It is a known fact that prime numbers are not evenly distributed. For example, almost all primes give the remainder 1 or 5 when divided by 6 (the only two exceptions are the primes 2 and 3). Your task is to write a program that will help explore this phenomenon.
// 
// 
// 
// You will be given three integers: lowerBound, upperBound and modulo. Return the remainder that occurs most often when we take all primes in the set { lowerBound, lowerBound+1, ... upperBound } and divide each of them by modulo. If there are multiple remainders that occur most often, return the smallest of them.
// 
// 
// DEFINITION
// Class:PrimeStatistics
// Method:mostCommonRemainder
// Parameters:int, int, int
// Returns:int
// Method signature:int mostCommonRemainder(int lowerBound, int upperBound, int modulo)
// 
// 
// NOTES
// -A prime number is a positive integer that has exactly two divisors. The first few primes are: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...
// 
// 
// CONSTRAINTS
// -lowerBound and upperBound are between 1 and 200,000 inclusive.
// -lowerBound is less than or equal to upperBound.
// -modulo is between 2 and 1000 inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 3
// 14
// 5
// 
// Returns: 3
// 
// The primes in this interval are: 3, 5, 7, 11 and 13. Their remainders when divided by 5 are 3, 0, 2, 1 and 3, respectively. Thus the most common remainder is 3.
// 
// 1)
// 3
// 33
// 1000
// 
// Returns: 3
// 
// In this case each of the primes gives a different remainder. According to the tie-breaking rule the smallest of them is returned.
// 
// 2)
// 25
// 27
// 17
// 
// Returns: 0
// 
// There are no primes in this interval. Each remainder occurs zero times, thus each of them is the most common remainder. Zero is the smallest possible remainder. Thus, according to the tie-breaking rule, zero is returned.
// 
// 3)
// 1
// 200000
// 2
// 
// Returns: 1
// 
// Almost all primes are odd; the only even prime is 2.
// 
// 4)
// 1
// 1000
// 6
// 
// Returns: 5
// 
// As mentioned in the introduction, almost all primes give the remainder 1 or 5 modulo 6. In this interval there are more primes of the second kind.
// 
// END KAWIGIEDIT TESTING
