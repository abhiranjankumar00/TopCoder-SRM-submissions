#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <climits>
#include <cstring>
using namespace std;

typedef long long  int64;
typedef vector<int> vi;
typedef string ST;
typedef stringstream SS;
typedef vector< vector <int> > vvi;
typedef pair<int,int> ii;
typedef vector <string> vs;

#define Pf	printf
#define	Sf	scanf

#define	ep	1e-9
#define PI M_PI
#define E M_E

#define	CL(a, b)	memset(a, b, sizeof(a))
#define	mp	make_pair

#define	pb	push_back

#define	all(c)	(c).begin(), (c).end()
#define	tr(i, c)	for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define	present(x, c)	((c).find(x) != (c).end())		//map & set//
#define	cpresent(x, c)	(find(all(c),x) != (c).end())	//vector & list//

#define forn(i, n)	for(int i = 0, loop_ends_here = (int)n; i < loop_ends_here; i++)
#define forab(i, a, b)	for(int i = a, loop_ends_here = (int) b; i <= loop_ends_here; i++)
#define rep(i, a, b)	for(int i = a, loop_ends_here = (int)b; i>=loop_ends_here; i--)

#define read(n)		scanf("%d", &n)
#define write(n)	printf("%d ", n)
#define writeln(n)	printf("%d\n", n)

class BoardSplitting
{
public:
	int minimumCuts(int desiredLength, int desiredCount, int actualLength);
};


int BoardSplitting::minimumCuts (int desiredLength, int desiredCount, int actualLength) 
{
	int ret;
	
	return ret;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2;
	cout << "]" << endl;
	BoardSplitting *obj;
	int answer;
	obj = new BoardSplitting();
	clock_t startTime = clock();
	answer = obj->minimumCuts(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	int p3;
	
	{
	// ----- test 0 -----
	p0 = 5;
	p1 = 4;
	p2 = 4;
	p3 = 3;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 6;
	p1 = 100;
	p2 = 3;
	p3 = 0;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 500;
	p1 = 5;
	p2 = 1000;
	p3 = 3;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 314;
	p1 = 159;
	p2 = 26;
	p3 = 147;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// A construction company recently ordered some boards of length desiredLength from a lumber company.  By mistake, the lumber company instead delivered boards of length actualLength.  The construction company doesn't have time to reissue the order, so instead they will cut and glue together the boards they have in order to form boards of the proper length.
// 
// The construction company needs desiredCount boards of length desiredLength.  The have an effectively unlimited supply of boards of length actualLength.  The construction company wants to use as few boards as possible.  If there are multiple ways to use the same number of boards, they want to perform as few cuts as possible.  Return the number of cuts they will perform.
// 
// DEFINITION
// Class:BoardSplitting
// Method:minimumCuts
// Parameters:int, int, int
// Returns:int
// Method signature:int minimumCuts(int desiredLength, int desiredCount, int actualLength)
// 
// 
// NOTES
// -A board is a one-dimensional piece of wood.  A single board of length L may be cut into two boards of length X and Y, provided X > 0, Y > 0, and X + Y = L.  Two boards of length X and Y may be glued together to form a board of length X + Y.
// 
// 
// CONSTRAINTS
// -desiredLength will be between 1 and 1000, inclusive.
// -desiredCount will be between 1 and 1000, inclusive.
// -actualLength will be between 1 and 1000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 5
// 4
// 4
// 
// Returns: 3
// 
// We need 4 boards of length 5 each. We have an unlimited supply of boards of length 4.  One solution is to cut one board into 4 pieces of length 1 each (using 3 cuts), then glue each piece to a board of length 4.
// 
// 1)
// 6
// 100
// 3
// 
// Returns: 0
// 
// No cuts are necessary.
// 
// 2)
// 500
// 5
// 1000
// 
// Returns: 3
// 
// We cut 3 boards in half.
// 
// 3)
// 314
// 159
// 26
// 
// Returns: 147
// 
// 
// 
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
